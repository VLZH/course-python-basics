---
id: basic_types
title: Базовые типы
---

import Link from "@theme/Link";

## Булевые типы (`True`/`False`)

Булевые типы в программировании используются для обозначения действительности или лжи. В `Python` булевые типы являются подклассом `int`:

```python
isinstance(False, int) # True
print(1 + True) # 2
print(1 + False) # 1

print(int(False)) # 0
print(int(True)) # 1

print(False + False) # 0
print(True + True) # 2
```


## None
Если False обозначение отрицание, то None обозначает отсутствие чего-либо.
```python
def foo():
  pass

bar = foo()
print(bar) # None
```
## Числа

В `Python` нет числел ограниченной длины, как например в `go`, где мы должны явно указывать какой длины у нас число... естественно в кол-ве бит под него.

Для выделения места под число, его инициализации используется `литерал числа`:

```python
4 # Это вполне корректная инструкция создания числа
```

Числа мы можем присваивать в переменные:

```python
some_int = 4
print(type(some_int)) # int
```

В примерах выше мы использовали тип `int`, помимо него в `python` присутствует отдельный тип для хранения чисел с плавающей точкой - `float`.

```python
some_float = 4.4
some_float2 = .4
print(type(some_float2)) # float
```

Помимо представленных видов объявления мы можем использовать литералы чисел с другой системой счисления:

```python
# Объявление в двоичной системе счисления
bit_int = 0b1000 # 8
# Объявление в шестранцатиричной системе счисления
hex_int = 0xFF # 255
```

### Представление числа в другой системе счисления:

Если мы хотим перевести число в шестнадцатиричную или двоичную строчку..., мы можем воспользоваться глобальными функциями `hex`, `bin`, `oct`

```python
print(hex(255)) # '0xff'
print(bin(8))   # '0b1000'
print(oct(8))   # '0o10'
```
### Sequnce (последовательность)¶
Как понятно из названия, последовательность - это последовательность каких-то значений. 
Если мы говорим про строки, то это последовательность символов в какой-то кодировке. 
А если говорим, про кортеж - это последовательность произвольных значений.
Существуют изменяемые(mutable) последовательности и неизменяемые(immutable).

## Строки
Строки это не изменяемыц тип данных 

Для объявления строк в python используются:

- `"some string"` - двойные кавычки
- `'some string'` - одинарные кавычки
- `"""some string"""` - двойные-тройные кавычки
- `'''some string'''` - одинарные-тройные кавычки

Строки бывают:

- `Юникодные(utf-8)`
- `байтовые`

В тройных кавычках вы можете переносить текст на следующую строчку, Т.е 'muliline strings'

```python
some_multiline_stirng = """
One
Two
Three
"""
```

Если в коде встречается несколько строчных литералов друг за другом, то они объединяются

```python
string = "string1" "string2"
print(string) # string1string2
```
Над строками можно совершать математические операции
```python

s1 = "Hello"
s2 = "World"


# Конкатенация строк (объединение)
s3 = s1 + s2
print(s3) # HelloWorld
s4 = s1 + " " + s2
print(s4) # Hello World
#
print(s1 * 3) # HelloHelloHello

```

> Когда-нибудь у вас возникнет вопрос, а как написать многострочный текст, без отступов слева, это можно будет сделать так:
>
> ```python
> SOME_MESSAGE_STRING = (
>     "Hello {name}\n"
>     "Your account balance: {balance}\n"
>     "Good luck!"
> )
> ```
>
> А вот второй способ:
>
> ```python
> from textwrap import dedent
> SOME_MESSAGE_STRING = dedent(f"""\
>     Hello {name}
>     Your account balance: {balance}
>     Good luck!
> """)
> ```

### Использование класса `str`

Если у нас есть последовательность байт, допустим прочитанных из файла, и мы хотим перевети их в строку, мы можем воспользоваться классом `str`

```python
some_bytes = b"red orange yellow"
some_string = str(some_bytes, 'utf-8')
```

Но как видите из кода вы долны так же указать кодировку вторым параметром. Вы так же будете часто использовать класс `str`, когда вам понадобится получить текстовое представление объекта. У объектов имеется магический метод `__str__` который должен возвращать строку, но есть загвоздка в том, что **прямое обращение к магическим методам не приветсвуется**, в этом случае вы можете воспользоваться классом `str`

```python
class Animal:
    def __str__(self):
        return "Animal class"
animal_instance = Animal()
print(str(animal_instance)) # "Animal class"
```

### Функция `repr`

Нужна чтобы вывести питоновское представление объекта, используется для дебагинга

```python
class Foo:
    def __repr__(self):
        return "Foo<>"
foo = Foo()
repr(foo)
```

### Форматирование строк

Очень частой задачей является подставлять значения в строки, в `Python 3.6` появился новый способ это делать, но прежде чем говорить про `f-strings`, стоит вспомнить пердыдущие способы.

#### Cтарые способы форматирования строк

- Используя старый синтаксис (`fprint`)

  ```python
  "%s:%s" % ("a", "b") # 'a:b'
  "%x:%x" % (1, 15) # '1:f'
  ```

  <Link
    title="printf-style String Formatting - Python documentation"
    href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting"
  />

- Используя метод строк `format`

  ```python
  "{}:{}".format("a", "b") # 'a:b'
  "{:0b}:{}".format(300, "b") # '100101100:b'
  ```

  <Link
    title="string - Python documentation"
    href="https://docs.python.org/3/library/string.html"
    caption="На этой странице вы найдете всевозможную информацию об форматировании строк... но чтиво конечно не из приятных"
  />

#### F-strings

В последних версиях `python` вы наконец можете удобнее подставлять значения с троки использую синтаксис `f-strings`, выглядит это следующим образом:

```python
first_name = "Jonh"
last_name = "Smith"
print("{first_name} {last_name}") # John Smith
```

<Link
  title="Formatted string literals - Python documentation"
  href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals"
/>

### Методы строк

Мы перечислим только некоторые из методов которые часто используются на практике:

- `str.encode() -> bytes` - перевести строку в `bytes` _"байтовую строчку"_

  ```python
  some_str = "some string"
  print(some_str.encode()) # b'some string'
  ```

- `str.split(separator: str, [limit: int]) -> List[str]` - разбить строку на подстроки
  ```python
  some_str = "a:b:c"
  print(some_str.split(":"))
  ```
- `str.lower() -> str` - привести символы к нижнему регистру
  ```python
  some_str = "ABC"
  print(some_str.lower()) # abc
  ```
- `str.upper() -> str` - привести символы к верхнему регистру
- `str.format(*args, **kwargs) -> str` - Подставить в места подстановки значения

Остальные примеры:

```python
print("  foo bar   ".strip()) # 'foo bar'
print("foo bar".replace("b", "_")) # 'foo _ar'
# Изменение регистра
print("foo bar".title())    # 'Foo Bar'
print("Foo Bar".swapcase()) # 'fOO bAR'
# Выравнивание
print("foo bar".center(18)) # '     foo bar      '
print("foo bar".ljust(18))  #  'foo bar           '
print("foo bar".rjust(18))  #  '           foo bar'
```

#### Официальная документация

<Link
  title="str - Python documentation"
  href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str"
  caption="За информацией о других методах обращайтесь по этой ссылке"
/>

## Коллекции

Коллекции хранят последовательности значений, они могут быть:

- изменяемые/неизменяемые - что определяет, можем ли мы в последовательность добавить новое значение, либо нет
- отсортированные/неотсортированные -

### Кортежи(tuple)

**Кортеж** в `python` - это **отсортированная** **неизменяемая** коллекция. Объявляется через **литерал объявления `tuple`** - `()`.

> Скобочки можно опускать

```python
t1 = (1,2,3)
t2 = 1, 2, 3
```
С таким синтаксисом, вам будет проще вернуть несколько значений из функции
```python
def foo():
    return 1, 2
x, y = foo()
print(x, y)
```

Попытка изменения кортежа не увенчается успехом, потому как уже сказанно - кортежи неизменяемы

### Списки(list)

**Список** в `python` - это **отсортированная** **изменяемая** коллекция. Объявляется через **литерал объявления `list`** - `[]`.

#### Объявление списка
```python
l1 = [1,2,3]
empty_list = []
foo = [1, "hello", 3.14, True]
bar = list(1, "hello", 3.14, True)
```
### Методы строк
- list.append() - Добавить объект в список
- list.insert(i, x) - Добавить значение x по индексу i
- list.extend(i, x) - Расширить последовательность другой последовательностью
- list.pop(index) - Вытащить объект из списка (по умолчанию с конца). Значит что значение будет удалено из списка и возвращено как результат вызова метода.
- list.remove(el) - Удалить значение из списка.
- list.clear() - Удалить все значения из списка

List (Список)
Это коллекция/последовательность, которая позволяет хранить множество объектов.

Объявление списка
foo = [1, "hello", 3.14, True]
bar = list(1, "hello", 3.14, True)
Методы списков
list.append() - Добавить объект в список
list.insert(i, x) - Добавить значение x по индексу i
list.extend(i, x) - Расширить последовательность другой последовательностью
list.pop(index) - Вытащить объект из списка (по умолчанию с конца). Значит что значение будет удалено из списка и возвращено как результат вызова метода.
list.remove(el) - Удалить значение из списка.
list.clear() - Удалить все значения из списка
### Оператор []
Используется для получения значения по индексу или изменения значения по индексу.
Для получения значения по индексу 1 из последовательности foo следует написать следующий код:
```python
foo[1]
```
### Примеры получения по индексу
```python
some_list = [ "H", "e", "l", "l", "o" ]
some_list[1] # e
some_list[4] # o
```
### Примеры изменения по индексу:

```python
some_list = [ "H", "e", "l", "l", "o" ]
some_list[4] = "0"
print(some_list) # ["H", "e", "l", "l", "0"]
```
### Удаление по индексу (Оператор del)¶

```python
some_list = [ "H", "e", "l", "l", "o" ]
del some_list[0]
print(some_list) # ["e", "l", "l", "o"]
```

```python
#      0, 1, 2, 3
foo = [1, 2, 3, 4]
# Положить значение   
foo.append(5)   # Текущее значение [1, 2, 3, 4, 5]
# Удалить значение из списка по индексу
del foo[3] #  Текущее значение [1, 2, 3, 5]
# Удалить значение из списка по значению
foo.remove(5)  # Текущее значение [1, 2, 3]
# Получить значение из списка
print("foo[0]:", foo[0])
# Изменить значение в списке
foo[0] = 10  #Текущее значение [10, 2, 3]
print("foo:", foo)
```

### Множеста(set)

**Множество** в `python` - это **неотсортированная** **изменяемая** коллекция. Объявляется через **литерал объявления `set`** - `{}`.

Но важный момент! Думаю, что вы заметите, что литералы словарей и множеств похожи, поэтому в следующем коде мы создадим пустой `dict`:
Представьте, что это список, но отличается он следующим:

- Он не может хранить дубли объектов
- Эта коллекция является неотсортированной
- Класс set предоставляет методы для операций над множествами, такие как: intersection/union/difference/symmetric difference
Для объявления множеста используется литерал множеста({}).

```python
empty_dict = {} # пустой словарь, не set!
```

Для инициализации пустого сета, нам понадобится вызвать метод: set()

```python
empty_set = set() # пустой словарь, не set!
```

#### Методы
- set.intersection(other) - Пересечение множеств
- set.union(other) - Oбъединение нескольких множеств
- set.difference(other) - Множество из всех элементов set, не принадлежащие ни одному из other
- set.symmetric_difference(other) - Множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих
```python
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

print("intersection:", set1.intersection(set2)) #intersection: {4, 5}
print("intersection(&):", set1 & set2) #intersection(&): {4, 5}

print("union:", set1.union(set2)) #union: {1, 2, 3, 4, 5, 6, 7, 8}
print("union(|):", set1 | set2) #union(|): {1, 2, 3, 4, 5, 6, 7, 8}

print("difference", set1.difference(set2)) #difference {1, 2, 3}
print("difference(-)", set1 - set2) #difference(-) {1, 2, 3}

print("symmetric difference", (set1 | set2) - (set1 & set2)) #symmetric difference {1, 2, 3, 6, 7, 8}
print("symmetric difference", set1.symmetric_difference(set2))  #symmetric difference {1, 2, 3, 6, 7, 8}
print("symmetric difference(^)", set1 ^ set2) #symmetric difference(^) {1, 2, 3, 6, 7, 8}
```
### Пример удаления дубликатов из списка


```python
list_1 = [
    "Двадцать тысяч льё под водой",
    "Двадцать тысяч льё под водой",
    "Судьба Жана Морена",
    "Чёрная Индия",
    "Южная звезда",
    "Южная звезда",
    "Пятьсот миллионов бегумы"
]

f_list = list(set(list_1))
print(f_list)
#['Чёрная Индия', 'Пятьсот миллионов бегумы', 'Двадцать тысяч льё под водой', 'Судьба Жана Морена', 'Южная звезда']
```



## Словари

Словари мы можем представлять как коробочки либо пеналы, где у каждого кармашка есть свое имя, для объявления словаря используется `литерал словаря`:

```python
new_dict = {
    "key1": 1,
    "key2": "value2"
}
```

либо через функцию `dict`:

```python
new_dict2 = dict([("key1", "value1"), ("key2", "value2")])
```

есть еще один вариант вызова функции `dict`:

```python
new_dict3 = dict(key1="value1", key2="value2")
```

### Обращение к значению словаря по ключу

Обращаться к значению словаря можно несколькими способами через оператор `[]`

```python
new_dict["key1"]
```

либо через метод словаря `dict.get(key: hashable, defalut: any)`

```python
new_dict.get("key1") # 1
new_dict.get("undefined_key", 3) # 3
```

### Добавление значения в словарь

Словари изменяемы и мы можем добавлять в них новые ключи:

```python
new_dict["key3"] = "value3"
```

### Удаление значения из словаря

Для удаления значения из словаря осуществляется с помощью оператора `del`

```python
del new_dict["key3"]
print(new_dict) # {"key1": 1, "key2": "value2"}
```

### Методы словаря

Наиболее полезными методами словаря являются:

- `dict.keys() -> List[hashable]` - Получение списка ключей словаря
- `dict.values() -> List[Any]` - Получение списка значений словаря
- `dict.items() -> Tuple[Tuple[hashable, Any]]` - Получение последовательности пар `(ключ, значение)`

```python
some_dict = {
  "a": 1,
  "b": 2
}
print(some_dict.keys()) # ["a", "b"]
print(some_dict.values()) # [1, 2]
print(some_dict.items()) # [("a", 1), ("b", 2)]
```

Для честности, стоит сказать, что перечисленные методы возвращают **не обычные списки**, а экземпляры специальных классов, но вы можете пока об этом не задумываться.
