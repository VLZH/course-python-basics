---
id: basic_types
title: Базовые типы
---

import Link from "@theme/Link";

## Булевые типы (`True`/`False`)

Булевые типы в программировании используются для обозначения действительности или лжи. В `Python` булевые типы являются подклассом `int`:

```python
isinstance(False, int) # True
print(1 + True) # 2
print(1 + False) # 1
```

## Числа

В `Python` нет числел ограниченной длины, как например в `go`, где мы должны явно указывать какой длины у нас число... естественно в кол-ве бит под него.

Для выделения места под число, его инициализации используется `литерал числа`:

```python
4 # Это вполне корректная инструкция создания числа
```

Числа мы можем присваивать в переменные:

```python
some_int = 4
print(type(some_int)) # int
```

В примерах выше мы использовали тип `int`, помимо него в `python` присутствует отдельный тип для хранения чисел с плавающей точкой - `float`.

```python
some_float = 4.4
some_float2 = .4
print(type(some_float2)) # float
```

Помимо представленных видов объявления мы можем использовать литералы чисел с другой системой счисления:

```python
# Объявление в двоичной системе счисления
bit_int = 0b1000 # 8
# Объявление в шестранцатиричной системе счисления
hex_int = 0xFF # 255
```

### Представление числа в другой системе счисления:

Если мы хотим перевести число в шестнадцатиричную или двоичную строчку..., мы можем воспользоваться глобальными функциями `hex`, `bin`, `oct`

```python
print(hex(255)) # '0xff'
print(bin(8))   # '0b1000'
print(oct(8))   # '0o10'
```

## Строки

Для объявления строк в python используются:

- `"some string"` - двойные кавычки
- `'some string'` - одинарные кавычки
- `"""some string"""` - двойные-тройные кавычки
- `'''some string'''` - одинарные-тройные кавычки

Строки бывают:

- `Юникодные(utf-8)`
- `байтовые`

В тройных кавычках вы можете переносить текст на следующую строчку, Т.е 'muliline strings'

```python
some_multiline_stirng = """
One
Two
Three
"""
```

Если в коде встречается несколько строчных литералов друг за другом, то они объединяются

```python
string = "string1" "string2"
print(string) # string1string2
```

> Когда-нибудь у вас возникнет вопрос, а как написать многострочный текст, без отступов слева, это можно будет сделать так:
>
> ```python
> SOME_MESSAGE_STRING = (
>     "Hello {name}\n"
>     "Your account balance: {balance}\n"
>     "Good luck!"
> )
> ```
>
> А вот второй способ:
>
> ```python
> from textwrap import dedent
> SOME_MESSAGE_STRING = dedent(f"""\
>     Hello {name}
>     Your account balance: {balance}
>     Good luck!
> """)
> ```

### Использование класса `str`

Если у нас есть последовательность байт, допустим прочитанных из файла, и мы хотим перевети их в строку, мы можем воспользоваться классом `str`

```python
some_bytes = b"red orange yellow"
some_string = str(some_bytes, 'utf-8')
```

Но как видите из кода вы долны так же указать кодировку вторым параметром. Вы так же будете часто использовать класс `str`, когда вам понадобится получить текстовое представление объекта. У объектов имеется магический метод `__str__` который должен возвращать строку, но есть загвоздка в том, что **прямое обращение к магическим методам не приветсвуется**, в этом случае вы можете воспользоваться классом `str`

```python
class Animal:
    def __str__(self):
        return "Animal class"
animal_instance = Animal()
print(str(animal_instance)) # "Animal class"
```

### Функция `repr`

Нужна чтобы вывести питоновское представление объекта, используется для дебагинга

```python
class Foo:
    def __repr__(self):
        return "Foo<>"
foo = Foo()
repr(foo)
```

### Форматирование строк

Очень частой задачей является подставлять значения в строки, в `Python 3.6` появился новый способ это делать, но прежде чем говорить про `f-strings`, стоит вспомнить пердыдущие способы.

#### Cтарые способы форматирования строк

- Используя старый синтаксис (`fprint`)

  ```python
  "%s:%s" % ("a", "b") # 'a:b'
  "%x:%x" % (1, 15) # '1:f'
  ```

  <Link
    title="printf-style String Formatting - Python documentation"
    href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting"
  />

- Используя метод строк `format`

  ```python
  "{}:{}".format("a", "b") # 'a:b'
  "{:0b}:{}".format(300, "b") # '100101100:b'
  ```

  <Link
    title="string - Python documentation"
    href="https://docs.python.org/3/library/string.html"
    caption="На этой странице вы найдете всевозможную информацию об форматировании строк... но чтиво конечно не из приятных"
  />

#### F-strings

В последних версиях `python` вы наконец можете удобнее подставлять значения с троки использую синтаксис `f-strings`, выглядит это следующим образом:

```python
first_name = "Jonh"
last_name = "Smith"
print("{first_name} {last_name}") # John Smith
```

<Link
  title="Formatted string literals - Python documentation"
  href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals"
/>

### Методы строк

Мы перечислим только некоторые из методов которые часто используются на практике:

- `str.encode() -> bytes` - перевести строку в `bytes` _"байтовую строчку"_

  ```python
  some_str = "some string"
  print(some_str.encode()) # b'some string'
  ```

- `str.split(separator: str, [limit: int]) -> List[str]` - разбить строку на подстроки
  ```python
  some_str = "a:b:c"
  print(some_str.split(":"))
  ```
- `str.lower() -> str` - привести символы к нижнему регистру
  ```python
  some_str = "ABC"
  print(some_str.lower()) # abc
  ```
- `str.upper() -> str` - привести символы к верхнему регистру
- `str.format(*args, **kwargs) -> str` - Подставить в места подстановки значения

Остальные примеры:

```python
print("  foo bar   ".strip()) # 'foo bar'
print("foo bar".replace("b", "_")) # 'foo _ar'
# Изменение регистра
print("foo bar".title())    # 'Foo Bar'
print("Foo Bar".swapcase()) # 'fOO bAR'
# Выравнивание
print("foo bar".center(18)) # '     foo bar      '
print("foo bar".ljust(18))  #  'foo bar           '
print("foo bar".rjust(18))  #  '           foo bar'
```

#### Официальная документация

<Link
  title="str - Python documentation"
  href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str"
  caption="За информацией о других методах обращайтесь по этой ссылке"
/>

## Коллекции

Коллекции хранят последовательности значений, они могут быть:

- изменяемые/неизменяемые - что определяет, можем ли мы в последовательность добавить новое значение, либо нет
- отсортированные/неотсортированные -

### Кортежи(tuple)

**Кортеж** в `python` - это **отсортированная** **неизменяемая** коллекция. Объявляется через **литерал объявления `tuple`** - `()`.

> Скобочки можно опускать

```python
t1 = (1,2,3)
t2 = 1, 2, 3
```

Попытка изменения кортежа не увенчается успехом, потому как уже сказанно - кортежи неизменяемы

### Списки(list)

**Список** в `python` - это **отсортированная** **изменяемая** коллекция. Объявляется через **литерал объявления `list`** - `[]`.

```python
l1 = [1,2,3]
empty_list = []
```

### Множеста(set)

**Множество** в `python` - это **неотсортированная** **изменяемая** коллекция. Объявляется через **литерал объявления `set`** - `{}`.

Но важный момент! Думаю, что вы заметите, что литералы словарей и множеств похожи, поэтому в следующем коде мы создадим пустой `dict`:

```python
empty_dict = {} # пустой словарь, не set!
```

Для инициализации пустого сета, нам понадобится вызвать метод: set()

```python
empty_set = set() # пустой словарь, не set!
```

#### Что мы можем делать с множествами?

> TODO: Дописать раздел

## Словари

Словари мы можем представлять как коробочки либо пеналы, где у каждого кармашка есть свое имя, для объявления словаря используется `литерал словаря`:

```python
new_dict = {
    "key1": 1,
    "key2": "value2"
}
```

либо через функцию `dict`:

```python
new_dict2 = dict([("key1", "value1"), ("key2", "value2")])
```

есть еще один вариант вызова функции `dict`:

```python
new_dict3 = dict(key1="value1", key2="value2")
```

### Обращение к значению словаря по ключу

Обращаться к значению словаря можно несколькими способами через оператор `[]`

```python
new_dict["key1"]
```

либо через метод словаря `dict.get(key: hashable, defalut: any)`

```python
new_dict.get("key1") # 1
new_dict.get("undefined_key", 3) # 3
```

### Добавление значения в словарь

Словари изменяемы и мы можем добавлять в них новые ключи:

```python
new_dict["key3"] = "value3"
```

### Удаление значения из словаря

Для удаления значения из словаря осуществляется с помощью оператора `del`

```python
del new_dict["key3"]
print(new_dict) # {"key1": 1, "key2": "value2"}
```

### Методы словаря

Наиболее полезными методами словаря являются:

- `dict.keys() -> List[hashable]` - Получение списка ключей словаря
- `dict.values() -> List[Any]` - Получение списка значений словаря
- `dict.items() -> Tuple[Tuple[hashable, Any]]` - Получение последовательности пар `(ключ, значение)`

```python
some_dict = {
  "a": 1,
  "b": 2
}
print(some_dict.keys()) # ["a", "b"]
print(some_dict.values()) # [1, 2]
print(some_dict.items()) # [("a", 1), ("b", 2)]
```

Для честности, стоит сказать, что перечисленные методы возвращают **не обычные списки**, а экземпляры специальных классов, но вы можете пока об этом не задумываться.
